# JSON
json_text = %({"x": 1, "y": 2})


# Requesting a url
# ---------------------------------
response = HTTP::Client.get "https://www.commissioncrowd.com"
response.status_code      # => 200
puts response.body.lines.first # => "<!doctype html>"


# Serving posts from markdown files
# ---------------------------------
if File.exists?("content/#{resource}.md")
    FrontMatter.open("content/#{resource}.md", skip_newlines: false) { |front_matter, content_io|
        fm = parse_frontmatter(front_matter)
        md = content_io.gets_to_end.as(String)
        options = Markd::Options.new(smart: true, safe: true)
        html = Markd.to_html(md, options).gsub("/bucket/", imgbucket)
        render_article ctx, resource, fm["title"], html
    }
else
    error ctx, "Page not found", HTTP::Status.new(404)
end

# List of files
# -----------------------------------
d = Dir.new("content")
files = d.each_child
render ctx, "src/templates/home.ecr", "The Crystal World"


# BASIC AUTH: client
document.body.addEventListener('htmx:configRequest', function(evt) {
    let target = evt.detail.target
    let headers = evt.detail.headers
    let params = evt.detail.parameters

    if(target.tagName === 'FORM' && target.classList.contains("login")) {
        headers['Authorization'] = "Basic " + b64EncodeUnicode(params.username + ":" + params.password);
        params.username = '';
        params.password = '';
    }
});

# BASIC AUTH: server
if hd = context.request.headers["Authorization"]?
    credstring = hd.split("Basic ")[1]?
    if credstring
        creds = Base64.decode_string(credstring).split(":")
        if creds[0] == env["USERNAME"] && creds[1] == env["PASSWORD"]
            context.response.status_code = 200
            context.response.print "ok"
            context.response.headers["HX-Redirect"] = "/about"
            context.response.redirect "/admin"
            next
        end
    end
end
context.response.status_code = 401
context.response.headers["WWW-Authenticate"] = "Basic realm=\"Login Required\""



# API ROUTE CONTEXT
#context.response.content_type = "application/json"
#context.response.headers["Access-Control-Request-Headers"] = "Content-Type, application/json"
#context.response.headers["Access-Control-Allow-Origin"] = "http://127.0.0.1:8080"
#context.response.headers["Access-Control-Allow-Credentials"] = "true"
#context.response.headers["Access-Control-Allow-Methods"] = "POST, GET, OPTIONS"
#context.response.headers["Access-Control-Allow-Content-Type"] = "application/json"
#context.response.headers["Access-Control-Allow-Headers"] = "Content-Type, Access-Control-Allow-Headers, Authorization, X-Requested-With"




# DB create
# -----------------------------------
Models.create_article(
    slug: "there-are-ghosts-in-this-room",
    title: fm["title"],
    tags: fm["tags"],
    date: "2015-04-25 00:00:00.000",
    image: false,
    imageClass: fm["imageclass"],
    draft: true,
    content: md
)

# Crinja
            template = tengine.get_template("base.html")
            puts template.render({
                "foo" => "jo"
            })


# OLD ECR RENDERING
def self.render_and_out(context, title, content, error_msg=nil)
    cachebust = Time.monotonic.to_s().split(".")[-1]
    header = ECR.render "src/templates/components/header.ecr"
    populated_layout = ECR.render "src/templates/layouts/base.ecr"
    context.response.content_type = "text/html; charset=UTF-8"
    context.response.print populated_layout
end


# SIGNUP

when "admin/signup"
    # On successful signup:
    sessionid = Random::Secure.hex(16)
    csrf_token = Random::Secure.hex(16)
    # TO STORE THE PASSWORD:
    securepwd = Argon2::Password.create("mypwd")
    # create database user


  # DOESN'T WORK
  on paste
    halt the event
    set ev to the event
    set el to <div.editable/>
    set data to ev.clipboardData.getData('text/html') or ev.clipboardData.getData('text/plain')
    set regex to '/<(?!(\/\s*)?(a|b|i|em|s|code|pre|strong|u)[>,\s])([^>])*>/g'
    set data to data.replace(regex, "")
    call document.execCommand('insertHTML', false, data)
  end

# JSON
#json_text = %({"html": "#{html}"})

      DB.open "sqlite3://./crw.db" do |db|
        begin
          if username
            userid, password, first_name, last_name, sessionid, csrftoken =
              db.query_one "SELECT id, password, first_name, last_name, sessionid, csrftoken " \
                          "FROM users WHERE username = ? LIMIT 1",
                username,
                as: {Int32, String, String?, String?, String?, String?}
          elsif sessionid
            userid, password, first_name, last_name, sessionid, csrftoken =
              db.query_one "SELECT id, password, first_name, last_name, sessionid, csrftoken " \
                          "FROM users WHERE sessionid = ? LIMIT 1",
                sessionid,
                as: {Int32, String, String?, String?, String?, String?}
          end
        rescue DB::NoResultsError
          puts "No user found"
          return nil
        end
        return {
          "id"         => userid,
          "password"   => password,
          "first_name" => first_name,
          "last_name"  => last_name,
          "sessionid"  => sessionid,
        }
      end



{
  "articles" => [
    #<CrystalWorld::Models::Article:0x7f2113814a00 @id=1, @date="2023-11-23 00:00:00.000", @slug="nova-by-samuel-r-delany-1968", @title="Nova by Samuel R. Delany (1968)", @tags="sf,  reviews", @main_image=nil, @image_class="mainImageSmaller", @draft=0>,
    #<CrystalWorld::Models::Article:0x7f21138149b0 @id=6, @date="2023-11-10 00:00:00.000", @slug="jg-ballards-crash-is-it-science-fiction", @title="J. G. Ballardâ€™s Crash: is it Science Fiction?", @tags="sf, literature, ballard", @main_image=nil, @image_class="mainImageSmaller", @draft=0>,
    #<CrystalWorld::Models::Article:0x7f2113814960 @id=7, @date="2023-11-10 00:00:00.000", @slug="a-stand-of-yellow-birch-trees", @title="A Stand of Yellow Birch Trees", @tags="philosophy, perception", @main_image=nil, @image_class="mainImageSmaller", @draft=0>,
    #<CrystalWorld::Models::Article:0x7f2113814910 @id=4, @date="2023-10-23 00:00:00.000", @slug="sanatorium", @title="Sanatorium", @tags="travel", @main_image=nil, @image_class="", @draft=0>,
    #<CrystalWorld::Models::Article:0x7f21138148c0 @id=5, @date="2023-10-10 00:00:00.000", @slug="crash-by-jg-ballard", @title="Crash by J. G. Ballard (1973)", @tags="sf, reviews, ballard", @main_image=nil, @image_class="mainImageSmaller", @draft=0>,
    #<CrystalWorld::Models::Article:0x7f2113814870 @id=9, @date="2021-02-05 00:00:00.000", @slug="post-war-soviet-modernist-architecture", @title="Remembering the Future, Soviet-style", @tags="nonfiction, modernism, reviews", @main_image=nil, @image_class="mainImageSmaller", @draft=0>,
    #<CrystalWorld::Models::Article:0x7f2113814820 @id=10, @date="2021-02-05 00:00:00.000", @slug="logicomix-an-epic-search", @title="Logicomix: An Epic Search for an Epic Search for Truth", @tags="philosophy, reviews", @main_image=nil, @image_class="mainImageSmallest", @draft=0>,
    #<CrystalWorld::Models::Article:0x7f21138147d0 @id=11, @date="2016-02-05 00:00:00.000", @slug="the-argument-for-indirect-realism", @title="The Argument for Indirect Realism", @tags="philosophy, perception", @main_image=nil, @image_class="", @draft=0>,
    #<CrystalWorld::Models::Article:0x7f2113814780 @id=12, @date="2015-04-25 00:00:00.000", @slug="there-are-ghosts-in-this-room", @title="There are Ghosts in This Room", @tags="philosophy, travel", @main_image=nil, @image_class="", @draft=0>,
    #<CrystalWorld::Models::Article:0x7f2113814730 @id=8, @date="2015-03-10 00:00:00.000", @slug="it-gets-lonely-downstairs", @title="It Gets Lonely Downstairs", @tags="philosophy, perception", @main_image=nil, @image_class="mainImageSmaller", @draft=0>
  ],
  "title" => "My Crystal World"
}


# WHEN TRYING TO USE DB::Serializable and DB::Mapping:
class Article
  include DB::Serializable
  property id : Int32
  property date : String
  property slug : String
  property title : String
  property tags : String?
  property main_image : String?
  property image_class : String?
  property draft : Int32

  DB.mapping({
    id: Int32,
    date: String,
    slug: String,
    title: String,
    tags: String?,
    main_image: String?,
    image_class: String?,
    draft: Int32,
  })

DB.open "sqlite3://./crw.db" do |db|
  begin
    articles = Article.from_rs(db.query "SELECT id, slug, title, date, tags, main_image, " \
                                        "image_class, draft FROM articles ORDER BY date DESC")
    return articles
  rescue DB::NoResultsError
    return nil
  end
end


    class User
      include DB::Serializable
      property id : Int32
      property first_name : String
      property last_name : String
      property sessionid : String
      property csrftoken : String
      property username : String
      property password : String


        #DB.open "sqlite3://./crw.db" do |db|
        #  begin
        #    if username
        #      user = User.from_rs(db.query(
        #        "SELECT id, username, password, first_name, last_name, sessionid, csrftoken " \
        #        "FROM users WHERE username = '#{username}' LIMIT 1"
        #        )
        #      )
        #    elsif sessionid
        #      user = User.from_rs(db.query(
        #        "SELECT id, username, password, first_name, last_name, sessionid, csrftoken " \
        #          "FROM users WHERE sessionid = '#{sessionid}' LIMIT 1"
        #        )
        #      )
        #    end
        #    if user
        #      user = user[0]
        #      return user # We can now use e.g., user.first_name
        #    end
        #  rescue DB::NoResultsError
        #    return nil
        #  end
        #end

          #begin
          #  user = User.from_rs(db.query(
          #    "SELECT id, username, password, first_name, last_name, sessionid, csrftoken " \
          #    "FROM users WHERE sessionid = '#{sessionid}' and csrftoken = '#{csrftoken}' LIMIT 1"
          #    )
          #  )
          #  return user
          #rescue DB::NoResultsError
          #  return nil
          #end


#
  def doFontStyle(mk)
    set div to <div.editable/>
    if window.getSelection
      set sel to window.getSelection()
      set selString to sel.toString()

      set range to sel.getRangeAt(0)
      set range2 to range.cloneRange()
      range2.setStart(range.startContainer, range.startOffset-2)
      range2.setEnd(range.startContainer, range.endOffset+2)
      ---log range2.toString()

      set replacementText to ""
      if selString.startsWith(mk) and selString.endsWith(mk)
        set replacementText to selString.split(mk)[1]
      else if range2.toString().startsWith(mk) and range2.toString().endsWith(mk)
        set replacementText to range2.toString().split(mk)[1]
        set range to range2
      else
        set replacementText to mk + selString + mk
      end

      call range2.deleteContents()

      if sel.rangeCount is greater than 0
        set range to sel.getRangeAt(0)
        call range.deleteContents()
        set txtNode to document.createTextNode(replacementText)
        call range.insertNode(txtNode)

        ---THE FOLLOWING IS KINDA POINTLESS IMO
        ---IT'S TO APPLY BOLD, ITALIC (ETC) TO THE MARKDOWN ITSELF,
        ---WITHIN THE MARKDOWN TEXT
        ---set elType to ""
        ---if mk == "**"
        ---  set elType to "strong"
        ---else if mk == "_"
        ---  set elType to "em"
        ---end
        ---if selString.startsWith(mk) and selString.endsWith(mk)
        ---  set elType to "span"
        ---end
        ---set newParent to document.createElement(elType)
        ---range.surroundContents(newParent)

      end
    end
  end

  # Above called by this on contenteditable:

on keydown[key is 'b' and ctrlKey is true]
  halt the event
  call doFontStyle('**') then call do_html(me.innerText)
on keydown[key is 'i' and ctrlKey is true]
  halt the event
  call doFontStyle('_') then call do_html(me.innerText)



  def admin_edit_preview(ctx)
    # *********************************
    # CURRENTLY NOT USED
    #
    if u = Data.authenticated_user ctx
      urlbits = ctx.request.path.split('/', remove_empty: true)
      slug = urlbits[-2]?
      article = Data.get_article slug
      if article
        TemplateRenderer.render_and_out ctx: ctx,
          data: {
            "article" => article,
            "title"   => article["title"],
          },
          template_path: "admin/article_preview.html"
        return
      end
      CrystalWorld::Controllers.error_404 ctx
      return
    end
  end




# DELAY
i = 0
s = ""
while i < 20000
  s += Random.rand.to_s
  i += 1
end
